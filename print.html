<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>OCaml Debugging and Performance</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="preface.html">Preface</a></li><li class="chapter-item expanded "><a href="native-debugging.html"><strong aria-hidden="true">1.</strong> Debugging support in the OCaml compiler</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="sample-debugging-session-gdb.html"><strong aria-hidden="true">1.1.</strong> GDB on Linux debugging session</a></li><li class="chapter-item expanded "><a href="sample-debugging-session-lldb.html"><strong aria-hidden="true">1.2.</strong> LLDB on MacOS debugging session</a></li><li class="chapter-item expanded "><a href="bytecode-debugging.html"><strong aria-hidden="true">1.3.</strong> Debugging bytecode</a></li></ol></li><li class="chapter-item expanded "><a href="profiling.html"><strong aria-hidden="true">2.</strong> Profiling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="profiling-perf.html"><strong aria-hidden="true">2.1.</strong> Using perf</a></li><li class="chapter-item expanded "><a href="flamegraphs-linux.html"><strong aria-hidden="true">2.2.</strong> Generating CPU Flamegraphs for OCaml on Linux</a></li><li class="chapter-item expanded "><a href="flamegraphs-macos.html"><strong aria-hidden="true">2.3.</strong> Generating CPU Flamegraphs for OCaml on MacOS</a></li><li class="chapter-item expanded "><a href="statmemprof-4-lts.html"><strong aria-hidden="true">2.4.</strong> Memory profiling with statmemprof in 4.14 LTS</a></li><li class="chapter-item expanded "><a href="statmemprof-5.html"><strong aria-hidden="true">2.5.</strong> Memory profiling with statmemprof in 5.3</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">OCaml Debugging and Performance</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/tmcgilchrist/ocaml-debug-performance" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="preface"><a class="header" href="#preface">Preface</a></h1>
<p>The premise of this collection of notes is to gather information about
OCaml Debugging and Performance, and provide a single source of information
about OCaml Performance and tooling, native OCaml debugging and related topics.</p>
<p>This work is inherently practical in nature, if you have a working knowledge of
OCaml and systems performance tools then it should be possible to follow along.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging-support-in-the-ocaml-compiler"><a class="header" href="#debugging-support-in-the-ocaml-compiler">Debugging support in the OCaml compiler</a></h1>
<!-- toc -->
<p>This document explains the state of debugging tools support in the OCaml compiler.
It gives an overview of GDB, LLDB, WinDbg/CDB, as well as infrastructure around OCaml
compiler to debug OCaml code.</p>
<p>The material contains both current support and ideas for future areas to improve.</p>
<h2 id="preliminaries"><a class="header" href="#preliminaries">Preliminaries</a></h2>
<h3 id="debuggers"><a class="header" href="#debuggers">Debuggers</a></h3>
<p>According to wikipedia <a href="https://en.wikipedia.org/wiki/Debugger">1</a></p>
<blockquote>
<p>A debugger or debugging tool is a computer program used to test and debug other programs (the &quot;target&quot; program).</p>
</blockquote>
<p>Writing a debugger from scratch for a language requries considerable work, especially if you want to support
various platforms like Linux, MacOS, and Windows. Existing debuggers like GDB and LLDB can be extended to support
debugging a language like OCaml. This is the path OCaml has chosen for what I'll call native debugging, debugging
exectuables compiled to object code via assembly and run on a CPU. OCaml also includes a debugger for the bytecode
exectuables it also produces, more on that later.</p>
<h3 id="dwarf"><a class="header" href="#dwarf">DWARF</a></h3>
<p>According to the <a href="http://dwarfstd.org">DWARF</a> standard website:</p>
<blockquote>
<p>DWARF is a debugging information file format used by many compilers and debuggers to support source level
debugging. It addresses the requirements of a number of procedural languages, such as C, C++, and Fortran,
and is designed to be extensible to other languages. DWARF is architecture independent and applicable to
any processor or operating system. It is widely used on Unix, Linux and other operating systems, as well
as in stand-alone environments.</p>
</blockquote>
<p>DWARF allows a compiler to describe how program source translates to assembly, using a data structure called
Debugging Information Entry (DIE) which stores the information as &quot;tags&quot; to denote functions, variables etc.,
e.g., <code>DW_TAG_variable</code>, <code>DW_TAG_pointer_type</code>, <code>DW_TAG_subprogram</code> etc.
You can also invent your own tags and attributes.</p>
<p>DWARF reader is a program that consumes the DWARF format and creates debugger compatible output.
This program may live in the compiler itself.</p>
<h3 id="codeviewpdb"><a class="header" href="#codeviewpdb">CodeView/PDB</a></h3>
<p><a href="https://llvm.org/docs/PDB/index.html">PDB</a> (Program Database) is a file format created by Microsoft that contains debug information.
PDBs can be consumed by debuggers such as WinDbg/CDB and other tools to display debug information.
A PDB contains multiple streams that describe debug information about a specific binary such
as types, symbols, and source files used to compile the given binary. CodeView is another
format which defines the structure of <a href="https://llvm.org/docs/PDB/CodeViewSymbols.html">symbol records</a> and <a href="https://llvm.org/docs/PDB/CodeViewTypes.html">type records</a> that appear within
PDB streams.</p>
<h3 id="compact-unwinding-format"><a class="header" href="#compact-unwinding-format">Compact Unwinding Format</a></h3>
<p>Apple introduced a new kind of unwinding info the “compact unwinding format” on Apple platforms like macOS and iOS.
The Clang compiler on those platforms emits this format along with DWARF CFI. The format is described by the implementation
in clang/llvm, with an independent description provided at <a href="https://faultlore.com/blah/compact-unwinding/">https://faultlore.com/blah/compact-unwinding/</a> and <a href="https://github.com/mstange/macho-unwind-info">https://github.com/mstange/macho-unwind-info</a> So to generate good backtraces on Apple platforms, you need to be able to parse and interpret compact unwinding tables. Further details of how Apple uses <a href="https://opensource.apple.com/source/gdb/gdb-250/doc/stabs.pdf">STABS</a> plus DWARF for debug info <a href="https://wiki.dwarfstd.org/Apple%27s_%22Lazy%22_DWARF_Scheme.md">https://wiki.dwarfstd.org/Apple%27s_%22Lazy%22_DWARF_Scheme.md</a>.</p>
<h2 id="supported-debuggers"><a class="header" href="#supported-debuggers">Supported debuggers</a></h2>
<h3 id="gdb"><a class="header" href="#gdb">GDB</a></h3>
<p>OCaml supports GBD on Linux for all OCaml supported platforms, it supports basic debugging like setting breakpoints, stepping,
backtraces etc. A sample GDB/Linux session is <a href="sample-debugging-session.html">shown here</a>.
Additionally there are GDB macros <a href="https://github.com/ocaml/ocaml/blob/trunk/tools/gdb-macros">gdb-macros</a> and Python macros <a href="https://github.com/ocaml/ocaml/blob/trunk/tools/gdb_ocamlrun.py">gdb_ocamlrun.py</a> that provide low-level debugging of OCaml programs and of the
OCaml runtime itself (both native and byte-code).</p>
<h4 id="ocaml-parser-extensions"><a class="header" href="#ocaml-parser-extensions">OCaml parser extensions</a></h4>
<p>To be able to show debug output, we need an expression parser. GDB expression parsers are written in [Bison],
and could be written to accept a subset of OCaml expressions, including printing OCaml values knowing the
boxed types used by OCaml. Read the <a href="https://dev.realworldocaml.org/runtime-memory-layout.html">Memory Representation of Values</a> chapter of RealWorld OCaml for more details.</p>
<p>Future work:</p>
<ul>
<li>Restore DWARF CFI for POWER native code</li>
<li>Port more GDB macros to Python</li>
<li>Add a source language to GDB https://sourceware.org/gdb/wiki/Internals%20Adding-a-Source-Language-to-GDB</li>
</ul>
<h3 id="lldb"><a class="header" href="#lldb">LLDB</a></h3>
<p>LLDB is the default debugger on MacOS, shipped with XCode and generally works the best on that platform.
It is also available on Linux and is the <a href="https://docs.freebsd.org/en/books/developers-handbook/tools/#debugging">default debugger for FreeBSD</a>.</p>
<ul>
<li>LLDB has a plugin architecture but that does not work for language support.</li>
<li>At present GDB generally works better on Linux.</li>
</ul>
<h4 id="ocaml-parser-extensions-1"><a class="header" href="#ocaml-parser-extensions-1">OCaml parser extensions</a></h4>
<p>This expression parser is written in C++. It is a type of Recursive Descent parser.</p>
<p>Some initial work on OCaml LLDB support at https://github.com/ocaml-flambda/llvm-project</p>
<p><strong>What is included here?</strong></p>
<h3 id="rr"><a class="header" href="#rr">RR</a></h3>
<p>rr is a lightweight tool for recording, replaying and debugging execution of applications (trees of
processes and threads). Debugging extends gdb with very efficient reverse-execution, which in
combination with standard gdb/x86 features like hardware data watchpoints, makes debugging much more
fun. OCaml supports RR on Linux for certain x86_64 and ARM64 platforms.</p>
<p>Future work:</p>
<ul>
<li>Validate RR on macOS/LLDB platform</li>
<li>Validate RR on Linux/LLDB platform</li>
<li>RR doesn't currently support Apple M3 chips see https://github.com/rr-debugger/rr/pull/3528</li>
</ul>
<h3 id="windbgcdb"><a class="header" href="#windbgcdb">WinDbg/CDB</a></h3>
<p>Microsoft provides <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/">Windows Debugging Tools</a> such as the Windows Debugger (WinDbg) and the Console Debugger (CDB)
which both support debugging programs that provide PDB information. These debuggers parse the debug info fpor a
binary from the PDB, if available, to construct a visualization to serve up in the debugger. Currently the OCaml
compiler does not produce PDB and future work is required to support debugging on Windows. Additionally OCaml on Windows
provides three different ports, complicating the matter further.</p>
<h2 id="dwarf-and-ocaml"><a class="header" href="#dwarf-and-ocaml">DWARF and OCaml</a></h2>
<p>DWARF is a widely-used format for representing debug information for
consumption by debugging tools but also for runtime systems and profiling.
DWARF information is typically embedded within an executable and provides
a way to represent a variety of information:</p>
<ul>
<li><em>line information</em> mapping instructions back to their location in the source
program. eg assembly instruction at address <code>x</code> originated from <code>main.ml</code>
at line 13</li>
<li><em>unwind information</em> allowing call chains to be reconstructed from the
runtime state of the exectution stack. eg OCaml program is currently
running function <code>x</code>, which was called from <code>y</code> and so on. This is
particularly interesting for multicore which introduced fibers and
effects, and their runtime managed stack segments.</li>
<li><em>type information</em> allowing debugging tools to reconstruct the structure
and identity of values from the runtime state of the program.
eg when an OCaml program is executing assembly instruction at address <code>x</code>
what is the OCaml value sitting in a register.</li>
</ul>
<p>This information allows debuggers (eg gdb or lldb) and profiling tools to do what they do.</p>
<p>The OCaml compiler has included DWARF support for some time, with the
large changes comming from OCaml 5 and the associated runtime changes
the DWARF support needed to be restored and improved.</p>
<p>There are a number of potential user-cases for DWARF information:</p>
<ol>
<li>Use in native debugging tools like <code>gdb</code> and <code>lldb</code></li>
<li>Statisical profiling using tools like perf</li>
<li>Computing call stacks for ThreadSanitizer, a data race detection tool</li>
</ol>
<h3 id="ocaml-to-dwarf-die-mapping"><a class="header" href="#ocaml-to-dwarf-die-mapping">OCaml to DWARF DIE Mapping</a></h3>
<p>Provide a small example of how OCaml gets mapped to DWARF DIEs</p>
<p>DW_TAG_base_type provide base type mappings that can be defined per language.
Should OCaml be using this to output DWARF representations.</p>
<p>DW_TAG_variable describes a variable in the source language</p>
<p>https://dwarfstd.org/doc/Debugging%20using%20DWARF-2012.pdf</p>
<pre><code>$ 
COMPILE_UNIT&lt;header overall offset = 0x00000047&gt;:
&lt; 0&gt;&lt;0x0000000b&gt;  DW_TAG_compile_unit
                    DW_AT_stmt_list             0x00000062
                    DW_AT_low_pc                0x0004b6a0
                    DW_AT_high_pc               0x0004b760
                    DW_AT_name                  fib.ml
                    DW_AT_comp_dir              /home/tsmc/ocaml
                    DW_AT_producer              GNU AS 2.41
                    DW_AT_language              DW_LANG_Mips_Assembler

LOCAL_SYMBOLS:
&lt; 1&gt;&lt;0x0000002e&gt;    DW_TAG_subprogram
                      DW_AT_name                  camlFib__main_1_3_code
                      DW_AT_external              yes(1)
                      DW_AT_type                  &lt;0x00000073&gt;
                      DW_AT_low_pc                0x0004b6f8
                      DW_AT_high_pc               0x0004b73c
&lt; 1&gt;&lt;0x00000045&gt;    DW_TAG_subprogram
                      DW_AT_name                  camlFib__fib_0_2_code
                      DW_AT_external              yes(1)
                      DW_AT_type                  &lt;0x00000073&gt;
                      DW_AT_low_pc                0x0004b6a0
                      DW_AT_high_pc               0x0004b6f4
&lt; 1&gt;&lt;0x0000005c&gt;    DW_TAG_subprogram
                      DW_AT_name                  camlFib__entry
                      DW_AT_external              yes(1)
                      DW_AT_type                  &lt;0x00000073&gt;
                      DW_AT_low_pc                0x0004b740
                      DW_AT_high_pc               0x0004b760
&lt; 1&gt;&lt;0x00000073&gt;    DW_TAG_unspecified_type
</code></pre>
<h2 id="ocaml-name-mangling"><a class="header" href="#ocaml-name-mangling">OCaml Name Mangling</a></h2>
<h2 id="what-is-missing"><a class="header" href="#what-is-missing">What is missing?</a></h2>
<h2 id="resources"><a class="header" href="#resources">Resources</a></h2>
<p>Tom Tromey discusses debugging support in rustc, provides a good overview of the area and what OCaml
might also want to do - <a href="https://www.youtube.com/watch?v=elBxMRSNYr4">https://www.youtube.com/watch?v=elBxMRSNYr4</a></p>
<p><a href="https://rustc-dev-guide.rust-lang.org/debugging-support-in-rustc.html">https://rustc-dev-guide.rust-lang.org/debugging-support-in-rustc.html</a></p>
<p>DWARF support in GHC (4 part series) <a href="https://well-typed.com/blog/2020/04/dwarf-1/">https://well-typed.com/blog/2020/04/dwarf-1/</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sample-gdb-on-linux-debugging-session"><a class="header" href="#sample-gdb-on-linux-debugging-session">Sample GDB on Linux debugging session</a></h1>
<p>Starting from an OCaml 4.14 switch, create one if it doesn't already exist with <code>opam switch create 4.14.1 --no-install</code>.</p>
<pre><code class="language-shell">$ opam switch
#  switch                                              compiler                    description
   4.14.1                                              ocaml-base-compiler.4.14.1  4.14.1
</code></pre>
<p>Consider this program:</p>
<pre><code class="language-ocaml">$ cat fib.ml
let rec fib n =
  if n &lt; 2 then 1
	else fib (n-1) + fib (n-2)

let main () =
  let r = fib 20 in
	Printf.printf &quot;fib(20) = %d&quot; r

let _ = main ()
</code></pre>
<p>compiled with</p>
<pre><code class="language-ocaml">$ ocamlopt -g -o fib.exe fib.ml
</code></pre>
<p>Here the OCaml from our fib program gets name mangled into the following:</p>
<pre><code class="language-ocaml">$ nm -pa fib.exe|grep &quot;camlFib&quot;
000000010005da58 D _camlFib
000000010005daf0 D _camlFib__1
000000010005dac8 D _camlFib__2
000000010005dab0 D _camlFib__3
000000010005da98 D _camlFib__4
000000010005da80 D _camlFib__5
000000010005da40 D _camlFib__6
000000010005da28 D _camlFib__7
0000000100003838 T _camlFib__code_begin
0000000100003928 T _camlFib__code_end
000000010005da20 D _camlFib__data_begin
000000010005db08 D _camlFib__data_end
00000001000038e8 T _camlFib__entry
0000000100003838 T _camlFib__fib_267
000000010005db10 D _camlFib__frametable
000000010005da68 D _camlFib__gc_roots
0000000100003890 T _camlFib__main_269
</code></pre>
<p>OCaml functions are mangled as <code>caml&lt;MODULENAME&gt;__&lt;FUNCTIONNAME&gt;_&lt;RANDOMINT&gt;</code>. The numbers used can be recovered from the lambda format. Re-running the command with <code>-dlambda</code> will output the lamdba form, and <code>-S</code> will output the assembly for the program as <code>fib.S</code>. You can see the symbol <code>_camlFib__main_269</code> is coming from the <code>main/269</code> seen in the lambda format.</p>
<pre><code class="language-ocaml">$ ocamlopt -dlambda -g -S -o fib.exe fib.ml
(seq
  (letrec
    (fib/267
       (function n/268[int] : int
         (if (&lt; n/268 2) 1
           (+ (apply fib/267 (- n/268 1)) (apply fib/267 (- n/268 2))))))
    (setfield_ptr(root-init) 0 (global Fib!) fib/267))
  (let
    (main/269 =
       (function param/308[int] : int
         (let (r/271 =[int] (apply (field 0 (global Fib!)) 20))
           (apply (field 1 (global Stdlib__Printf!))
             [0: [11: &quot;fib(20) = &quot; [4: 0 0 0 0]] &quot;fib(20) = %d&quot;] r/271))))
    (setfield_ptr(root-init) 1 (global Fib!) main/269))
  (apply (field 1 (global Fib!)) 0) 0 0)
</code></pre>
<pre><code class="language-ocaml">$ gdb fib.exe
GNU gdb (Ubuntu 14.0.50.20230907-0ubuntu1) 14.0.50.20230907-git
Copyright (C) 2023 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type &quot;show copying&quot; and &quot;show warranty&quot; for details.
This GDB was configured as &quot;aarch64-linux-gnu&quot;.
Type &quot;show configuration&quot; for configuration details.
For bug reporting instructions, please see:
&lt;https://www.gnu.org/software/gdb/bugs/&gt;.
Find the GDB manual and other documentation resources online at:
    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.

For help, type &quot;help&quot;.
Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...
Reading symbols from fib.exe...
(gdb) break camlFib__fib_267
Breakpoint 1 at 0x4f9b8: file fib.ml, line 1.
(gdb) r
Starting program: /home/tsmc/ocaml/fib-4.14.1.exe 
[Thread debugging using libthread_db enabled]
Using host libthread_db library &quot;/lib/aarch64-linux-gnu/libthread_db.so.1&quot;.

Breakpoint 1, camlFib__fib_267 () at fib.ml:1
1	let rec fib n =
(gdb) bt
#0  camlFib__fib_267 () at fib.ml:1
#1  0x0000aaaaaaaefa2c in camlFib__main_269 () at fib.ml:6
#2  0x0000aaaaaaaefa98 in camlFib__entry () at fib.ml:9
#3  0x0000aaaaaaaec0a4 in caml_program ()
#4  0x0000aaaaaab337d4 in caml_start_program ()
#5  0x0000aaaaaab34090 in caml_startup_common (argv=0xaaaaaab709c8, 
    pooling=&lt;optimized out&gt;, pooling@entry=0) at startup_nat.c:160
#6  0x0000aaaaaab34110 in caml_startup_exn (argv=&lt;optimized out&gt;)
    at startup_nat.c:167
#7  caml_startup (argv=&lt;optimized out&gt;) at startup_nat.c:172
#8  caml_main (argv=&lt;optimized out&gt;) at startup_nat.c:179
#9  0x0000aaaaaaaebdd0 in main (argc=&lt;optimized out&gt;, argv=&lt;optimized out&gt;)
    at main.c:37
(gdb) 

</code></pre>
<p>Observe that I have the full backtrace all the way from the main function in the runtime.</p>
<p>You can keep continuing and the backtrace continues to build up, showing the recursive calls to fib.</p>
<pre><code class="language-ocaml">(gdb) c
Continuing.

Breakpoint 1, camlFib__fib_267 () at fib.ml:1
1	let rec fib n =
(gdb) bt
#0  camlFib__fib_267 () at fib.ml:1
#1  0x0000aaaaaaaef9e4 in camlFib__fib_267 () at fib.ml:3
#2  0x0000aaaaaaaefa2c in camlFib__main_269 () at fib.ml:6
#3  0x0000aaaaaaaefa98 in camlFib__entry () at fib.ml:9
#4  0x0000aaaaaaaec0a4 in caml_program ()
#5  0x0000aaaaaab337d4 in caml_start_program ()
#6  0x0000aaaaaab34090 in caml_startup_common (argv=0xaaaaaab709c8, pooling=&lt;optimized out&gt;, pooling@entry=0)
    at startup_nat.c:160
#7  0x0000aaaaaab34110 in caml_startup_exn (argv=&lt;optimized out&gt;) at startup_nat.c:167
#8  caml_startup (argv=&lt;optimized out&gt;) at startup_nat.c:172
#9  caml_main (argv=&lt;optimized out&gt;) at startup_nat.c:179
#10 0x0000aaaaaaaebdd0 in main (argc=&lt;optimized out&gt;, argv=&lt;optimized out&gt;) at main.c:37
(gdb) c
Continuing.

Breakpoint 1, camlFib__fib_267 () at fib.ml:1
1	let rec fib n =
(gdb) bt
#0  camlFib__fib_267 () at fib.ml:1
#1  0x0000aaaaaaaef9e4 in camlFib__fib_267 () at fib.ml:3
#2  0x0000aaaaaaaef9e4 in camlFib__fib_267 () at fib.ml:3
#3  0x0000aaaaaaaefa2c in camlFib__main_269 () at fib.ml:6
#4  0x0000aaaaaaaefa98 in camlFib__entry () at fib.ml:9
#5  0x0000aaaaaaaec0a4 in caml_program ()
#6  0x0000aaaaaab337d4 in caml_start_program ()
#7  0x0000aaaaaab34090 in caml_startup_common (argv=0xaaaaaab709c8, pooling=&lt;optimized out&gt;, pooling@entry=0)
    at startup_nat.c:160
#8  0x0000aaaaaab34110 in caml_startup_exn (argv=&lt;optimized out&gt;) at startup_nat.c:167
#9  caml_startup (argv=&lt;optimized out&gt;) at startup_nat.c:172
#10 caml_main (argv=&lt;optimized out&gt;) at startup_nat.c:179
#11 0x0000aaaaaaaebdd0 in main (argc=&lt;optimized out&gt;, argv=&lt;optimized out&gt;) at main.c:37
(gdb)
</code></pre>
<p>Here we are on Linux / ARM64, so while the values cannot be printed directly, I know that the arguments are sent in registers, for ARM64 the first 4 arguments are passed in registers x0-x3. I can examine the value at entry to the function like so:</p>
<pre><code class="language-ocaml">(gdb) p $x0 &gt;&gt; 1
$1 = 16
(gdb) 
</code></pre>
<p>right shifting by 1 due to OCaml value representation, which uses 31 bits for integer values.</p>
<pre><code class="language-ocaml">(gdb) c
Continuing.

Breakpoint 1, camlFib__fib_267 () at fib.ml:1

(gdb) p $x0 &gt;&gt; 1
$3 = 14
</code></pre>
<p>You can also set break points based on the line numbers in gbd.</p>
<pre><code class="language-ocaml">(gdb) list
1	let rec fib n =
2	  if n &lt; 2 then 1
3	  else fib (n-1) + fib (n-2)
4	
5	let main () =
6	  let r = fib 20 in
7	  Printf.printf &quot;fib(20) = %d&quot; r
8	
9	let _ = main ()
(gdb) break fib.ml:6
Breakpoint 2 at 0xaaaaaaaefa28: file fib.ml, line 6.
</code></pre>
<p>From this point you can run the entire OCaml program, setting breakpoints and interacting with it as you would a regular C/C++ program. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sample-lldb-on-macos-session"><a class="header" href="#sample-lldb-on-macos-session">Sample LLDB on MacOS session</a></h1>
<p>Starting from an OCaml 4.14 switch, create one if it doesn't already exist with <code>opam switch create 4.14.1 --no-install</code>.</p>
<pre><code class="language-shell">$ opam switch
#  switch                                              compiler                    description
   4.14.1                                              ocaml-base-compiler.4.14.1  4.14.1
</code></pre>
<p>Consider this program:</p>
<pre><code class="language-ocaml">$ cat fib.ml
let rec fib n =
  if n &lt; 2 then 1
	else fib (n-1) + fib (n-2)

let main () =
  let r = fib 20 in
	Printf.printf &quot;fib(20) = %d&quot; r

let _ = main ()
</code></pre>
<p>compiled with</p>
<pre><code class="language-ocaml">$ ocamlopt -g -o fib-4.14.1.exe fib.ml
</code></pre>
<p>Here the OCaml from our fib program gets name mangled into the following:</p>
<pre><code class="language-ocaml">$ nm -pa fib-4.14.1.exe|grep &quot;camlFib&quot;
000000010005da58 D _camlFib
000000010005daf0 D _camlFib__1
000000010005dac8 D _camlFib__2
000000010005dab0 D _camlFib__3
000000010005da98 D _camlFib__4
000000010005da80 D _camlFib__5
000000010005da40 D _camlFib__6
000000010005da28 D _camlFib__7
0000000100003838 T _camlFib__code_begin
0000000100003928 T _camlFib__code_end
000000010005da20 D _camlFib__data_begin
000000010005db08 D _camlFib__data_end
00000001000038e8 T _camlFib__entry
0000000100003838 T _camlFib__fib_267
000000010005db10 D _camlFib__frametable
000000010005da68 D _camlFib__gc_roots
0000000100003890 T _camlFib__main_269
</code></pre>
<p>OCaml functions are mangled as <code>caml&lt;MODULENAME&gt;__&lt;FUNCTIONNAME&gt;_&lt;RANDOMINT&gt;</code>. The numbers used can be recovered from the lambda format. Re-running the command with <code>-dlambda</code> will output the lamdba form, and <code>-S</code> will output the assembly for the program as <code>fib.S</code>. You can see the symbol <code>_camlFib__main_269</code> is coming from the <code>main/269</code> seen in the lambda format.</p>
<pre><code class="language-ocaml">$ ocamlopt -dlambda -g -S -o fib-4.14.1.exe fib.ml
(seq
  (letrec
    (fib/267
       (function n/268[int] : int
         (if (&lt; n/268 2) 1
           (+ (apply fib/267 (- n/268 1)) (apply fib/267 (- n/268 2))))))
    (setfield_ptr(root-init) 0 (global Fib!) fib/267))
  (let
    (main/269 =
       (function param/308[int] : int
         (let (r/271 =[int] (apply (field 0 (global Fib!)) 20))
           (apply (field 1 (global Stdlib__Printf!))
             [0: [11: &quot;fib(20) = &quot; [4: 0 0 0 0]] &quot;fib(20) = %d&quot;] r/271))))
    (setfield_ptr(root-init) 1 (global Fib!) main/269))
  (apply (field 1 (global Fib!)) 0) 0 0)
</code></pre>
<pre><code class="language-ocaml"> $ lldb fib-4.14.1.exe 
(lldb) target create &quot;fib-4.14.1.exe&quot;
Current executable set to '/Users/tsmc/projects/ocaml/fib-4.14.1.exe' (arm64).
(lldb) br s -n camlFib__fib_267
Breakpoint 1: where = fib-4.14.1.exe`camlFib__code_begin, address = 0x0000000100003838
(lldb) r
Process 63927 launched: '/Users/tsmc/projects/ocaml/fib-4.14.1.exe' (arm64)
Process 63927 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1
    frame #0: 0x0000000100003838 fib-4.14.1.exe`camlFib__code_begin
fib-4.14.1.exe`camlFib__code_begin:
-&gt;  0x100003838 &lt;+0&gt;:  sub    sp, sp, #0x20
    0x10000383c &lt;+4&gt;:  str    x30, [sp, #0x18]
    0x100003840 &lt;+8&gt;:  cmp    x0, #0x5
    0x100003844 &lt;+12&gt;: b.ge   0x100003858               ; &lt;+32&gt;
Target 0: (fib-4.14.1.exe) stopped.
(lldb) bt
* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1
  * frame #0: 0x0000000100003838 fib-4.14.1.exe`camlFib__code_begin
    frame #1: 0x00000001000038ac fib-4.14.1.exe`camlFib__code_begin + 116
    frame #2: 0x0000000100029c44 fib-4.14.1.exe`caml_startup_common(argv=&lt;unavailable&gt;, pooling=&lt;unavailable&gt;) at startup_nat.c:160:9 [opt]
    frame #3: 0x0000000100029cb8 fib-4.14.1.exe`caml_main [inlined] caml_startup_exn(argv=&lt;unavailable&gt;) at startup_nat.c:167:10 [opt]
    frame #4: 0x0000000100029cb0 fib-4.14.1.exe`caml_main [inlined] caml_startup(argv=&lt;unavailable&gt;) at startup_nat.c:172:15 [opt]
    frame #5: 0x0000000100029cb0 fib-4.14.1.exe`caml_main(argv=&lt;unavailable&gt;) at startup_nat.c:179:3 [opt]
    frame #6: 0x0000000100029d18 fib-4.14.1.exe`main(argc=&lt;unavailable&gt;, argv=&lt;unavailable&gt;) at main.c:37:3 [opt]
    frame #7: 0x000000018863d0e0 dyld`start + 2360
</code></pre>
<p>Observe that I have the full backtrace all the way from the main function in the runtime.</p>
<p>You can keep continuing and the backtrace continues to build up, showing the recursive calls to fib.</p>
<pre><code class="language-ocaml">(lldb) bt
* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1
  * frame #0: 0x0000000100003838 fib-4.14.1.exe`camlFib__code_begin
    frame #1: 0x0000000100003864 fib-4.14.1.exe`camlFib__code_begin + 44
    frame #2: 0x00000001000038ac fib-4.14.1.exe`camlFib__code_begin + 116
    frame #3: 0x0000000100029c44 fib-4.14.1.exe`caml_startup_common(argv=&lt;unavailable&gt;, pooling=&lt;unavailable&gt;) at startup_nat.c:160:9 [opt]
    frame #4: 0x0000000100029cb8 fib-4.14.1.exe`caml_main [inlined] caml_startup_exn(argv=&lt;unavailable&gt;) at startup_nat.c:167:10 [opt]
    frame #5: 0x0000000100029cb0 fib-4.14.1.exe`caml_main [inlined] caml_startup(argv=&lt;unavailable&gt;) at startup_nat.c:172:15 [opt]
    frame #6: 0x0000000100029cb0 fib-4.14.1.exe`caml_main(argv=&lt;unavailable&gt;) at startup_nat.c:179:3 [opt]
    frame #7: 0x0000000100029d18 fib-4.14.1.exe`main(argc=&lt;unavailable&gt;, argv=&lt;unavailable&gt;) at main.c:37:3 [opt]
    frame #8: 0x000000018863d0e0 dyld`start + 2360
(lldb) c
Process 63927 resuming
Process 63927 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1
    frame #0: 0x0000000100003838 fib-4.14.1.exe`camlFib__code_begin
fib-4.14.1.exe`camlFib__code_begin:
-&gt;  0x100003838 &lt;+0&gt;:  sub    sp, sp, #0x20
    0x10000383c &lt;+4&gt;:  str    x30, [sp, #0x18]
    0x100003840 &lt;+8&gt;:  cmp    x0, #0x5
    0x100003844 &lt;+12&gt;: b.ge   0x100003858               ; &lt;+32&gt;
Target 0: (fib-4.14.1.exe) stopped.
(lldb) bt
* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1
  * frame #0: 0x0000000100003838 fib-4.14.1.exe`camlFib__code_begin
    frame #1: 0x0000000100003864 fib-4.14.1.exe`camlFib__code_begin + 44
    frame #2: 0x0000000100003864 fib-4.14.1.exe`camlFib__code_begin + 44
    frame #3: 0x00000001000038ac fib-4.14.1.exe`camlFib__code_begin + 116
    frame #4: 0x0000000100029c44 fib-4.14.1.exe`caml_startup_common(argv=&lt;unavailable&gt;, pooling=&lt;unavailable&gt;) at startup_nat.c:160:9 [opt]
    frame #5: 0x0000000100029cb8 fib-4.14.1.exe`caml_main [inlined] caml_startup_exn(argv=&lt;unavailable&gt;) at startup_nat.c:167:10 [opt]
    frame #6: 0x0000000100029cb0 fib-4.14.1.exe`caml_main [inlined] caml_startup(argv=&lt;unavailable&gt;) at startup_nat.c:172:15 [opt]
    frame #7: 0x0000000100029cb0 fib-4.14.1.exe`caml_main(argv=&lt;unavailable&gt;) at startup_nat.c:179:3 [opt]
    frame #8: 0x0000000100029d18 fib-4.14.1.exe`main(argc=&lt;unavailable&gt;, argv=&lt;unavailable&gt;) at main.c:37:3 [opt]
    frame #9: 0x000000018863d0e0 dyld`start + 2360
(lldb)
</code></pre>
<p>Here we are on MacOS / ARM64, so while the values cannot be printed directly, I know that the arguments are sent in registers, for ARM64 the first 4 arguments are passed in registers x0-x3. I can examine the value at entry to the function like so:</p>
<pre><code class="language-ocaml">(lldb) p $x0 &gt;&gt; 1
(unsigned long) 16
(lldb)  
</code></pre>
<p>right shifting by 1 due to OCaml value representation, which uses 31 bits for integer values.</p>
<pre><code class="language-ocaml">(lldb) c
Process 63927 resuming
Process 63927 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1
    frame #0: 0x0000000100003838 fib-4.14.1.exe`camlFib__code_begin
fib-4.14.1.exe`camlFib__code_begin:
-&gt;  0x100003838 &lt;+0&gt;:  sub    sp, sp, #0x20
    0x10000383c &lt;+4&gt;:  str    x30, [sp, #0x18]
    0x100003840 &lt;+8&gt;:  cmp    x0, #0x5
    0x100003844 &lt;+12&gt;: b.ge   0x100003858               ; &lt;+32&gt;
Target 0: (fib-4.14.1.exe) stopped.
(lldb) p $x0 &gt;&gt; 1
(unsigned long) 14
</code></pre>
<p>From this point you can run the entire OCaml program, setting breakpoints and interacting with it as you would a regular C/C++ program.</p>
<h2 id="issues"><a class="header" href="#issues">Issues</a></h2>
<ul>
<li>Setting breakpoints using line numbers eg <code>br s -f fib.ml -l 6</code> does not work in 4.14 or 5.*</li>
<li>Setting breakpoints using symbols eg <code>br s -n camlFib__fib_267</code> is broken in OCaml 5.1 onwards. OCaml 5.1 changed name mangling to use <code>.</code> separators over <code>__</code> which breaks lldb on MacOS. Linux LLDB is unaffected.</li>
<li>Backtraces in 4.14 onwards show offset <code>camlFib__code_begin + 116</code> rather than line number in source code</li>
<li>Backtraces in 5.0 onwards missing C code for OCaml runtime setup, beginning at <code>camlFib__code_begin</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging-ocaml-bytecode"><a class="header" href="#debugging-ocaml-bytecode">Debugging OCaml bytecode</a></h1>
<!-- toc -->
<h2 id="preliminaries-1"><a class="header" href="#preliminaries-1">Preliminaries</a></h2>
<h3 id="debuggers-1"><a class="header" href="#debuggers-1">Debuggers</a></h3>
<p>OCaml includes a compiler that produces bytecode and an interpreter for that bytecode.
There are two supported options for debugging bytecode.</p>
<ol>
<li><a href="https://v2.ocaml.org/releases/5.1/manual/debugger.html#s%3Ainf-debugger">ocamldebug</a> - provided with the compiler distribution</li>
<li><a href="https://github.com/hackwaly/ocamlearlybird">ocamlearlybird</a> - VSCode integrated debugger using DAP</li>
</ol>
<p>Both options reuse the protocol from <em>ocamldebug</em> to interface with the bytecode executables.</p>
<h3 id="dap"><a class="header" href="#dap">DAP</a></h3>
<p>The Debug Adapter Protocol (DAP) defines the abstract protocol used between a development tool (e.g. IDE or editor) and a debugger. The idea behind the Debug Adapter Protocol (DAP) is to abstract the way how the debugging support of development tools communicates with debuggers or runtimes into a protocol. By using DAP OCaml debugging can be integrated with many different IDEs or editors. See <a href="https://microsoft.github.io/debug-adapter-protocol/">https://microsoft.github.io/debug-adapter-protocol/</a>.</p>
<h3 id="what-is-missing-1"><a class="header" href="#what-is-missing-1">What is missing?</a></h3>
<ul>
<li>ocamldebug support for DAP</li>
<li>No support for MinGW or MSVC Windows ports</li>
<li>DAP integration for Vim / Emacs - status unknown</li>
<li>Limited support for Domains in bytecode debug - single domain only</li>
<li>support for effects - status unknown</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="profiling"><a class="header" href="#profiling">Profiling</a></h1>
<p>This is an attempt to map the software profiling ecosystem, with a focus on the OCaml programming language.
A review / survey of profilers, their data formats, analysis UIs and converters between data formats.</p>
<img src="profiling-tools.svg" alt="Architecture of profiling tools, visualisations and data formats" width="600"/>
<h2 id="profilers"><a class="header" href="#profilers">Profilers</a></h2>
<p>There are a number of different profilers available for OCaml, each with their strengths and usecases.</p>
<table><thead><tr><th align="left">Profiler</th><th align="left">Purpose</th><th align="left">Profile Data Format</th><th>Link</th></tr></thead><tbody>
<tr><td align="left">olly</td><td align="left">observability tools around the runtime events tracing system introduced in OCaml 5.0</td><td align="left">Chrome Tracing Format (JSON), Fuchsia Trace Format</td><td><a href="">runtime-events-tool</a></td></tr>
<tr><td align="left">magic-trace</td><td align="left">collects and displays high-resolution traces of what a process is doing</td><td align="left">Fuchsia Trace Format</td><td><a href="">magic-trace</a></td></tr>
<tr><td align="left">memtrace</td><td align="left">Statistical Memory Profiling for OCaml aka statmemprof</td><td align="left">Common Trace Format (CTF)</td><td><a href="">memtrace</a></td></tr>
<tr><td align="left">eio-trace</td><td align="left">eio-trace can be used to record and display traces of programs using the <a href="">eio</a> library</td><td align="left">Fuchsia Trace Format</td><td><a href="">eio-trace</a></td></tr>
<tr><td align="left"></td><td align="left"></td><td align="left"></td><td></td></tr>
<tr><td align="left">perf</td><td align="left">General-purpose profiler that uses hardware performance counters on Linux</td><td align="left">Common Trace Format (CTF)</td><td></td></tr>
<tr><td align="left">Instruments</td><td align="left">General-purpose profiler that comes with Xcode on macOS</td><td align="left"></td><td></td></tr>
<tr><td align="left">dtrace</td><td align="left">General Performance analysis tool for FreeBSD, Solaris and MacOS</td><td align="left"></td><td><a href="">dtrace</a></td></tr>
<tr><td align="left">eBPF</td><td align="left">General Performance analysis tool for Linux (similar to DTrace)</td><td align="left"></td><td></td></tr>
</tbody></table>
<p>The intent is to have a minimal set of Profile Data Formats produced by OCaml tooling that can be used with existing Analysis UI tools.</p>
<h2 id="visualisation-and-analysis-ui"><a class="header" href="#visualisation-and-analysis-ui">Visualisation and Analysis UI</a></h2>
<table><thead><tr><th align="left">Name</th><th align="left">Description</th><th align="left">Profile Data Format</th><th>Link</th></tr></thead><tbody>
<tr><td align="left">Perfetto</td><td align="left">System profiling, app tracing and trace analysis</td><td align="left">Fuchsia Trace Format (others)</td><td><a href="">perfetto.dev</a></td></tr>
<tr><td align="left">Speedscope</td><td align="left">An interactive flamegraph visualizer</td><td align="left">Various</td><td><a href="">github.com/jlfwong/speedscope</a></td></tr>
<tr><td align="left">memtrace_viewer</td><td align="left">Statistical Memory Profiler</td><td align="left">CTF</td><td><a href="">github.com/janestreet/memtrace_viewer</a></td></tr>
<tr><td align="left">flamegraph</td><td align="left">Stack trace visualiser</td><td align="left">Folded Stacks</td><td><a href="">www.brendangregg.com/flamegraphs.html</a></td></tr>
<tr><td align="left">flamescope</td><td align="left">Visualization tool for exploring different time ranges as Flame Graphs</td><td align="left">Linux perf script</td><td><a href="">github.com/Netflix/flamescope</a></td></tr>
<tr><td align="left">pprof</td><td align="left">Visualise profiling data as directed graph or flamegraphs</td><td align="left">Protocol Buffers</td><td><a href="">github.com/google/pprof</a></td></tr>
</tbody></table>
<h2 id="profile-data-format"><a class="header" href="#profile-data-format">Profile Data Format</a></h2>
<p>Chrome Tracing Format is a textual JSON also know as Trace Event Format or Chrome Performance Profile.
<a href="https://docs.google.com/document/d/1CvAClvFfyA5R-PhYUmn5OOQtYMH4h6I0nSsKchNAySU/preview">spec</a>
No OCaml libraries for reading / writing</p>
<p>Fuchsia Trace Format is a binary format used to collect, store, and transmit trace records. Focuses on performance.
<a href="https://fuchsia.googlesource.com/fuchsia/+/refs/heads/main/docs/reference/tracing/trace-format.md">spec</a>
Two libraries for reading / writing <a href="https://github.com/c-cube/ocaml-trace">trace-fuchsia</a> and
<a href="https://github.com/janestreet/tracing">tracing</a>.</p>
<p>Common Trace Format is a binary trace format designed to be very fast to write. Uses a declaritive language called
the <em>Trace Stream Description Language</em> TSDL to describe trace stream layout.
<a href="https://diamon.org/ctf/">spec</a>
No OCaml libraries for reading / writing</p>
<h2 id="converters"><a class="header" href="#converters">Converters</a></h2>
<p>Nothing to see here!</p>
<h2 id="walk-throughs"><a class="header" href="#walk-throughs">Walk throughs</a></h2>
<ul>
<li>Generating CPU Flamegraphs for OCaml on Linux <a href="flamegraphs-linux.html">here</a></li>
<li>Generating CPU Flamegraphs for OCaml on MacOS <a href="flamegraphs-macos.html">here</a></li>
<li>Memory profiling with statmemprof in <a href="statmemprof-4-lts.html">4.14 LTS</a> and <a href="statmemprof-5.html">5.3</a></li>
</ul>
<h2 id="resources-1"><a class="header" href="#resources-1">Resources</a></h2>
<p>This format was inspired by <a href="https://profilerpedia.markhansen.co.nz">https://profilerpedia.markhansen.co.nz</a></p>
<p>Prior art:</p>
<ul>
<li>OCaml-bench profiling notes <a href="https://github.com/ocaml-bench/notes/blob/master/profiling_notes.md">https://github.com/ocaml-bench/notes/blob/master/profiling_notes.md</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="profiling-ocaml-with-perf"><a class="header" href="#profiling-ocaml-with-perf">Profiling OCaml with perf</a></h1>
<ul>
<li>
<p>perf support for DWARF vs FP vs LBR</p>
</li>
<li>
<p>Importance of DWARF for performance tools like perf</p>
</li>
</ul>
<p>Take content from <a href="https://github.com/ocaml/ocaml/issues/12563">ocaml/ocaml#12563</a>,
<a href="https://github.com/ocaml/ocaml/pull/11144">ocaml/ocaml#11144</a>
and <a href="https://github.com/ocaml/ocaml/pull/11031">ocaml/ocaml#11031</a></p>
<p>LBR descriptions <a href="https://lwn.net/Articles/680985/">https://lwn.net/Articles/680985/</a>
and <a href="https://lwn.net/Articles/680996/">https://lwn.net/Articles/680996/</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generating-ocaml-flamegraphs-on-linux"><a class="header" href="#generating-ocaml-flamegraphs-on-linux">Generating OCaml flamegraphs on Linux</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generating-ocaml-flamegraphs-on-macos"><a class="header" href="#generating-ocaml-flamegraphs-on-macos">Generating OCaml flamegraphs on MacOS</a></h1>
<p>Flame Graphs are a visualisation for sampled stack frames. They provide a great way to visualise stack traces of profiled software to identify the most frequent code-paths and optimise them. Popularised by Brendan Gregg <em>loads</em> more information can be found on his blog https://www.brendangregg.com/flamegraphs.html</p>
<p>Here we are interested in how we can generate Flame Graphs for OCaml programs on macOS.
macOS is what I use for development work and I could not find other documentation on how to do this.
So here we are.</p>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<p>First we need <strong>XCode</strong> and Instruments installed, get them via the App Store by searching for XCode and installing that. <strong>Instruments.app</strong> is Apple's profiling tool for capturing and visualising traces, along with many other interesting things. It is built on top of the DTrace tracing framework from OpenSolaris, which was ported to Mac OS X v10.5 and is available in all following versions of macOS. Dtrace is very cool and deserves its own post on how to use it effectively on OCaml programs.</p>
<p>After XCode is installed confirm that Instruments is also installed, this command will find the <code>xctrace</code> executable:</p>
<pre><code class="language-shell">$ xcrun --find xctrace
/Applications/Xcode.app/Contents/Developer/usr/bin/xctrace
</code></pre>
<p><code>xctrace</code> is a command line version of Instruments which allows capturing traces from a terminal. To run a Time Profiler against an OCaml process use the following command, substituing <em>PROGRAM</em> with the OCaml executable. Often found under <code>_build/default</code> directory of a Dune project. For my project the executable is called<code>./_build/default/stress/stress.exe</code></p>
<pre><code class="language-shell">$ xctrace record --output . --template &quot;Time Profiler&quot; \
                 --target-stdout - --launch -- PROGRAM
</code></pre>
<p>This will create a trace file ending in <code>.trace</code>, open that trace file in Instruments, select the <code>Time Profiler</code> and select a Stack Thread in the lower left pane. Choose Select Edit &gt; Deep Copy from the menu and paste the output into a file called <code>ocaml-program.trace</code>. On MacOS Sonoma using Instruments 15.2 it looks like:</p>
<p><img src="macos-instruments-screen.png" alt="instruments-screenshot" /></p>
<p>Next download the Perl file https://github.com/brendangregg/FlameGraph/blob/master/stackcollapse-instruments.pl
to reduce the trace into a format that Flame Graphs can understand. You will need to make it executable with <code>chmod +x stackcollapse-instruments.pl</code></p>
<pre><code class="language-shell">./stackcollapse-instruments.pl ocaml-program.trace &gt; ocaml-program.outfile
</code></pre>
<p>Then download the Flame Graph tool https://github.com/brendangregg/FlameGraph/blob/master/flamegraph.pl and
run that against the outfile created by stackcollapse-instruments. Again make it executable with <code>chmod +x</code></p>
<pre><code class="language-shell">./flamegraph.pl ocaml-program.outfile &gt; ocaml-program.svg
</code></pre>
<p>This will produce an application level Flame Graph of the traced application stored in <code>ocaml-program.svg</code>.
Open that up in a Browser and click around to see where your OCaml program is spending it's time.</p>
<p>Another visualisation option is https://www.speedscope.app which can take the <code>.trace</code> file and produce a Flame Graph, without needing to run any scripts locally.</p>
<h2 id="in-practice-flame-graph-for-solver-service"><a class="header" href="#in-practice-flame-graph-for-solver-service">In Practice: Flame Graph for solver-service</a></h2>
<p>Recently I have been looking at the performance of the <a href="http://github.com/ocurrent/solver-service">solver-service</a> which is used to perform opam solves for the OCaml Continuous Integration services run by Tarides. The code uses OCaml 5 with EIO and is expected to scale across multiple CPUs.</p>
<p>I used this xctrace command to run the stress test, setting some Garbage Collection parameters:</p>
<pre><code class="language-shell">$ xctrace record --template &quot;Time Profiler&quot; \
                 --env=OCAMLRUNPARAM=&quot;M=352&quot; --target-stdout \
                 - --launch -- ./_build/default/stress/stress.exe local \
                 --cache-dir=./cache --count=10
...
Solved warm-up requests in: 12.37s
Running another 10 solves...
10/10 complete
Solved 10 requests in 10.06s (1.01s/iter) (15.91 solves/s)
Target app exited, ending recording...
Recording completed. Saving output file...
Output file saved as: Launch_stress.exe_2024-01-18_11.45.55_042428AC.trace
$ open Launch_stress.exe_2024-01-18_11.45.55_042428AC.trace
# Export data into a file called `macos-solver-02.trace`
$ ./stackcollapse-instruments.pl macos-solver-02.trace &gt; macos-solver-02.outfile
$ ./flamegraph.pl macos-solver-02.outfile &gt; macos-solver-02.svg
</code></pre>
<p>Producing this Flame Graph for the service. Note this was running on a 12 core M3Pro MacBookPro hence the 12 peaks relating to OCaml 5 using all available cores in this machine.
<img src="macos-flamegraph.svg" alt="macos-solver-02" /></p>
<p>Next step is working out where time is being spend and where we can speed up things.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="finding-memory-leaks-with-memtrace"><a class="header" href="#finding-memory-leaks-with-memtrace">Finding memory leaks with Memtrace</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="finding-memory-leaks-with-memtrace-1"><a class="header" href="#finding-memory-leaks-with-memtrace-1">Finding memory leaks with Memtrace</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
                <script type="text/javascript" src="mermaid.min.js"></script>
                <script type="text/javascript" src="mermaid-init.js"></script>
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
